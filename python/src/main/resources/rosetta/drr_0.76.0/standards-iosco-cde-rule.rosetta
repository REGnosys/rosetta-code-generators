namespace drr.standards.iosco.cde
version "0.76.0"

import cdm.base.staticdata.party.*
import cdm.base.math.*
import cdm.base.datetime.*
import cdm.base.datetime.daycount.*
import cdm.base.staticdata.identifier.*

import cdm.observable.asset.*

import cdm.product.template.*
import cdm.product.common.settlement.*
import cdm.product.asset.*
import cdm.product.qualification.*

import cdm.event.common.*
import cdm.event.workflow.*

import drr.regulation.common.*

body Authority BIS <"The Bank for International Settlements (BIS) is an international financial institution owned by central banks that fosters international monetary and financial cooperation and serves as a bank for central banks">

body Authority CPMI <"The Committee on Payments and Market Infrastructures (CPMI) is an international standard setter that promotes, monitors and makes recommendations about the safety and efficiency of payment, clearing, settlement and related arrangements, thereby supporting financial stability and the wider economy. The CPMI also serves as a forum for central bank cooperation in related oversight, policy and operational matters, including the provision of central bank services.">

body Authority IOSCO <"The International Organization of Securities Commissions (IOSCO) is the international body that brings together the world's securities regulators and is recognized as the global standard setter for the securities sector. IOSCO develops, implements and promotes adherence to internationally recognized standards for securities regulation. It works intensively with the G20 and the Financial Stability Board (FSB) on the global regulatory reform agenda.">

body Authority CPMI_IOSCO <"IOSCO and the Committee on Payments and Market Infrastructures (CPMI) work together to enhance coordination of standard and policy development and implementation, regarding clearing, settlement and reporting arrangements including financial market infrastructures (FMIs) worldwide. FMIs, which include central counterparties (CCPs), trade repositories (TRs), central securities depositories (CSDs), securities settlement systems (SSSs), and payment systems (PSs), play an essential role in the global financial system. IOSCO and the CPMI monitor the implementation of the Principles for financial market infrastructures (PFMI), which are international standards for payment systems, central securities depositories, securities settlement systems, central counterparties and trade repositories. The PFMI are designed to help ensure the safety, efficiency and resilience of these infrastructures supporting global financial markets - so their full, timely and consistent implementation is fundamental. CPMI and IOSCO members have committed to adopting the principles and responsibilities contained in the PFMI in line with the G20 expectations.">

corpus TechnicalGuidance "Harmonisation of Critical Data Elements (other than UTI and UPI)" CDE <"The G20 Leaders agreed in 2009 that all over-the-counter (OTC) derivative transactions should be reported to trade repositories (TRs) to further the goals of improving transparency, mitigating systemic risk and preventing market abuse.1 Aggregation of the data being reported across TRs will help authorities to obtain a comprehensive view of the OTC derivatives market and its activity. Such aggregation is feasible if the work on standardisation and harmonisation of important data elements [is] completed.2 Since November 2014, the CPMI and IOSCO working group for the harmonisation of key OTC derivatives data elements (Harmonisation Group) has worked to develop global guidance regarding the definition, format and usage of key OTC derivatives data elements reported to TRs, including the Unique Transaction Identifier (UTI), the Unique Product Identifier (UPI) and other critical data elements. Technical Guidance on the Harmonisation of the Unique Transaction Identifier (UTI) was published in February 20173 and Technical Guidance on the Harmonisation of the Unique Product Identifier (UPI) was published in September 2017.4 The CPMI and IOSCO also published consultative reports on a first, a second and a third batch of critical data elements other than UTI and UPI in September 2015, October 2016 and June 2017, respectively">

corpus UPITechnicalGuidance "Harmonisation of the Unique Product Identifier" UPI <"This document (the Technical Guidance) provides authorities with technical guidance on a uniform global Unique Product Identifier (UPI). 1 A number of reports2 have identified OTC derivatives data elements  including the UPI  that are critical to many aspects of regulatory work. This report envisions a system under which a unique UPI code would be assigned to each distinct OTC derivative product and each UPI code would map to a set of data comprised of eference data elements with specific values that together describe the product. The collection of reference data elements and their values for each product would reside in a corresponding UPI reference data library.">

//CDE Definitions

reporting rule CDEEffectiveDate <"Effective Date">
	[regulatoryReference CPMI_IOSCO CDE section "2" field "1"
		rationale_author "DRR"
		rationale "The rule does not report adjusted dates since CFTC explicity indicates that dates should be reported unadjusted"
		provision "Unadjusted date at which obligations under the OTC derivative transaction come into effect, as included in the confirmation"]
	extract TradeForEvent( ReportableEvent ) then
		extract
		//Look for unadjusted dates only.
		//TH Review -> should map effectiveDate for vol/var 
		if Trade -> tradableProduct -> product -> contractualProduct -> economicTerms -> effectiveDate -> adjustableDate -> unadjustedDate exists
			then Trade -> tradableProduct -> product -> contractualProduct -> economicTerms -> effectiveDate -> adjustableDate -> unadjustedDate
		else if Trade -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> optionPayout -> underlier -> contractualProduct -> economicTerms -> effectiveDate -> adjustableDate -> unadjustedDate exists
			then Trade -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> optionPayout -> underlier -> contractualProduct -> economicTerms -> effectiveDate -> adjustableDate -> unadjustedDate
		//check unadjustedDate for interestRatePayout
		else if Trade -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> calculationPeriodDates -> effectiveDate -> adjustableDate -> unadjustedDate exists
			then Trade -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> calculationPeriodDates -> effectiveDate -> adjustableDate -> unadjustedDate
		//check unadjustedDate for equityPayout
		/*else if Trade -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> equityPayout -> calculationPeriodDates -> effectiveDate -> adjustableDate -> unadjustedDate exists
			then Trade -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> equityPayout -> calculationPeriodDates -> effectiveDate -> adjustableDate -> unadjustedDate*/
		//TH -> eq2perf update proposal : remove the prev "else if" statement completely. All EQ should report effectiveDate at economicTerms level

		//option - american exercise - unadjustedDate
		else if Trade -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> optionPayout -> exerciseTerms -> optionStyle -> americanExercise -> commencementDate -> adjustableDate -> unadjustedDate exists 
			then Trade -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> optionPayout -> exerciseTerms -> optionStyle -> americanExercise -> commencementDate -> adjustableDate -> unadjustedDate
		//option - bermudan exercise - unadjustedDate
		else if Trade -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> optionPayout -> exerciseTerms -> optionStyle -> bermudaExercise -> bermudaExerciseDates -> adjustableDates -> unadjustedDate exists 
			then Trade -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> optionPayout -> exerciseTerms -> optionStyle -> bermudaExercise -> bermudaExerciseDates -> adjustableDates -> unadjustedDate
		//check for IRswaption
		else if Qualify_InterestRate_Option_Swaption (Trade -> tradableProduct -> product -> contractualProduct -> economicTerms) then Trade -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> optionPayout -> underlier -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> calculationPeriodDates -> effectiveDate -> adjustableDate -> unadjustedDate
		//check for CRSwaption
		else if Qualify_CreditDefaultSwaption ( Trade -> tradableProduct -> product -> contractualProduct -> economicTerms) then Trade -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> optionPayout -> underlier -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> calculationPeriodDates -> effectiveDate -> adjustableDate -> unadjustedDate

func CDEExpirationDate: <"Expiration Date">
	[regulatoryReference CPMI_IOSCO CDE section "2" field "2"
		rationale_author "DRR"
		rationale "The rule does not report adjusted dates since CFTC explicitly indicates that dates should be reported unadjusted"
		provision "Unadjusted date at which obligations under the OTC derivative transaction stop being effective, as included in the confirmation. Early termination does not affect this data element."]
	inputs: product Product (1..1)
	output: expirationDate date (0..1)
	alias economicTerms: product -> contractualProduct -> economicTerms
	set expirationDate:
        // Look first for unadjusted dates. If unadjusted dates are not available, even at the leg level, then check for adjusted dates
        if economicTerms -> terminationDate -> adjustableDate -> unadjustedDate exists then
            economicTerms -> terminationDate -> adjustableDate -> unadjustedDate
        // check unadjustedDate for interestRatePayout
        else if economicTerms -> payout -> interestRatePayout -> calculationPeriodDates -> terminationDate -> adjustableDate -> unadjustedDate exists then
            economicTerms -> payout -> interestRatePayout -> calculationPeriodDates -> terminationDate -> adjustableDate -> unadjustedDate max
        // option - european exercise - unadjustedDate
        else if economicTerms -> payout -> optionPayout -> exerciseTerms -> optionStyle -> europeanExercise -> expirationDate -> adjustableDate -> unadjustedDate exists then
            economicTerms -> payout -> optionPayout -> exerciseTerms -> optionStyle -> europeanExercise -> expirationDate -> adjustableDate -> unadjustedDate max
        // option - bermuda exercise - unadjustedDate
        else if economicTerms -> payout -> optionPayout -> exerciseTerms -> optionStyle -> bermudaExercise -> bermudaExerciseDates -> adjustableDates -> unadjustedDate exists then
            economicTerms -> payout -> optionPayout -> exerciseTerms -> optionStyle -> bermudaExercise -> bermudaExerciseDates -> adjustableDates -> unadjustedDate max
        // option - american exercise - unadjustedDate
        else if economicTerms -> payout -> optionPayout -> exerciseTerms -> optionStyle -> americanExercise -> expirationDate -> adjustableDate -> unadjustedDate exists then
            economicTerms -> payout -> optionPayout -> exerciseTerms -> optionStyle -> americanExercise -> expirationDate -> adjustableDate -> unadjustedDate max
        // TH REVIEW: FX expiration date = valueDate for option and fwd
        else if economicTerms -> payout -> forwardPayout -> settlementTerms -> settlementDate -> valueDate exists then
            economicTerms -> payout -> forwardPayout -> settlementTerms -> settlementDate -> valueDate max
        else if economicTerms -> payout -> optionPayout -> settlementTerms -> settlementDate -> valueDate exists then
            economicTerms -> payout -> optionPayout -> settlementTerms -> settlementDate -> valueDate max
		//TH Review -> Needs confirmation (Is endDate the same as terminationDate for vol/var?)
		else if economicTerms -> payout -> performancePayout-> observationTerms-> observationDates->periodicSchedule->endDate-> adjustableDate -> unadjustedDate exists then 
			economicTerms -> payout -> performancePayout-> observationTerms-> observationDates->periodicSchedule->endDate-> adjustableDate -> unadjustedDate max
        else if IsCommodity( product ) then
            economicTerms -> payout -> commodityPayout -> schedule -> schedulePeriod -> fixingPeriod -> endDate max

reporting rule CDEReportingTimestamp <"Reporting Timestamp">
  	[regulatoryReference CPMI_IOSCO CDE section "2" field "4"
  		provision "Date and time of the submission of the report to the trade repository."]
			return Now ()

reporting rule CDEExecutionTimestamp <"Execution Timestamp">
  	[regulatoryReference CPMI_IOSCO CDE section "2" field "5"
  		provision "Date and time a transaction was originally executed, resulting in the generation of a new UTI. This data element remains unchanged throughout the life of the UTI."]
  	extract ReportableEvent -> originatingWorkflowStep -> timestamp then
  		filter when EventTimestamp -> qualification = EventTimestampQualificationEnum -> executionDateTime
  			then extract EventTimestamp -> dateTime

func CDECounterparty1: <"Counterparty 1 (reporting counterparty)">
    [regulatoryReference CPMI_IOSCO CDE section "2" field "6"
        provision "Identifier of the counterparty to an OTC derivative transaction who is fulfilling its reporting obligation via the report in question. In jurisdictions where both parties must report the transaction, the identifier of Counterparty 1 always identifies the reporting counterparty. In the case of an allocated derivative transaction executed by a fund manager on behalf of a fund, the fund and not the fund manager is reported as the counterparty."]
    inputs:
        reportableEvent ReportableEvent (1..1)
        supervisoryBody SupervisoryBodyEnum (1..1)
    output: lei string (0..1)
    alias reportingParty: ExtractReportingParty( reportableEvent -> reportableInformation -> partyInformation, supervisoryBody )
    set lei: PartyLei( reportingParty -> partyId )

func CDECounterparty2: <"Counterparty 2">
    [regulatoryReference CPMI_IOSCO CDE section "2" field "7"
		rationale "Peer review recommnended to detect private individual party representations (instead of LEI scheme)."
		rationale_author "Peer Review WG - 07/03/2022"
        provision "Identifier of the second counterparty to an OTC derivative transaction. In the case of an allocated derivative transaction executed by a fund manager on behalf of a fund, the fund and not the fund manager is reported as the counterparty."]
        //For natural persons who are acting as private individuals (not business entities): LEI of the reporting counterparty followed by a unique identifier assigned and maintained consistently by the reporting counterparty for that natural person(s) for regulatory reporting purpose.
	inputs:
        reportableEvent ReportableEvent (1..1)
        supervisoryBody SupervisoryBodyEnum (1..1)
    output: leiAndPerson string (0..1)
    alias tradeCounterparties: TradeForEvent( reportableEvent ) -> tradableProduct -> counterparty -> partyReference
    alias reportingCounterparty: ExtractCounterparty( reportableEvent -> reportableInformation -> partyInformation, supervisoryBody, tradeCounterparties )
    set leiAndPerson: PartyLeiAndPersonByRoles( reportingCounterparty, reportableEvent -> reportableInformation -> partyInformation, [NaturalPersonRoleEnum->Buyer, NaturalPersonRoleEnum->Seller] )

reporting rule CDECounterparty2IdentifierSource <"Counterparty 2 Identifier Source">
	[regulatoryReference CPMI_IOSCO CDE section "2" field "8"
		rationale "Peer review recommnended to detect private individual party representations (instead of LEI scheme)."
		rationale_author "Peer Review WG - 07/03/2022"
		provision "Indicator of whether LEI was used to identify the Counterparty 2"]
    extract TradeForEvent( ReportableEvent ) -> tradableProduct -> counterparty -> partyReference
            filter [item = ExtractCounterparty( ReportableEvent -> reportableInformation -> partyInformation, SupervisoryBodyEnum -> CFTC, TradeForEvent( ReportableEvent ) -> tradableProduct -> counterparty -> partyReference )] then
		extract if Party-> person exists and Party -> person -> personId -> identifierType any = PersonIdentifierTypeEnum -> NPID
            then "NPID"
        else if Party -> partyId -> identifierType any = PartyIdentifierTypeEnum -> LEI and Party-> person is absent
			then "LEI"

// 2.13 Direction
// Reporting counterparties should use either:
//  - the element Direction 1 or Buyer identifier and Seller identifier to identify the direction of the transaction for the reporting counterparty as Buyer or Seller (model 1); or
//  - the element Direction 2 or Payer identifier and Receiver identifier to identify the payer and the receiver of each leg (model 2).
// Reporting counterparties should NOT use both approaches, but adopt the appropriate one for the type of instrument concerned.
func CDEDirection1BuyerIdentifier:
[regulatoryReference CPMI_IOSCO CDE section "2" field "13" dataElement "1"
		rationale "Splitting definition into separate rules for Buyer and Seller"
		rationale_author "BNPP"
		rationale "Discussed on US Compliance WG - confirmed as per ISDA best practice for direction provided to CPMI-IOSCO best practice and CFTC tiebreaker logic  - Interest rate FRA  should be reported as payer/receiver."
		rationale_author "DRR US Compliance WG - 23/11/21"
		rationale "Peer review recommended to detect private individual party representations (instead of LEI scheme)."
		rationale_author "07/03 Peer review - 07/03/2022"
		provision "Identifier of the counterparty that is the buyer and the counterparty that is the seller, as determined at the time of the transaction.
			A non-exhaustive list of examples of instruments for which this data element could apply are:
				- most forwards and forward-like contracts (except for foreign exchange forwards and foreign exchange non-deliverable forwards)
				- most options and option-like contracts including swaptions, caps and floors
				- credit default swaps (buyer/seller of protection)
				- variance, volatility and correlation swaps
				- contracts for difference and spreadbets
			This data element is not applicable to instrument types covered by data elements Direction 2 or by Payer identifier and Receiver identifier."]
	inputs: trade Trade(1..1)
			partyInformation PartyInformation(1..*)
	output: leiAndPerson string (0..1)
	alias counterparty:
			if trade -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> optionPayout exists then
				ExtractCounterpartyByRole(
					trade -> tradableProduct -> counterparty,
					trade -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> optionPayout only-element -> buyerSeller -> buyer )
			else if IsCreditDefaultSwap( trade -> tradableProduct -> product ) then
				ExtractCounterpartyByRole(
					trade -> tradableProduct -> counterparty,
					trade -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> payerReceiver -> receiver )
			//TH Review -> should apply to all VOL/VAR/CORR swaps. Correlation pending
			else if IsVarianceSwap (trade -> tradableProduct -> product ) or IsVolatilitySwap (trade -> tradableProduct -> product ) then
				ExtractCounterpartyByRole(
					trade -> tradableProduct -> counterparty,
					trade -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> performancePayout only-element -> payerReceiver -> receiver )
			// TH review -> for commodity forwards only. As of 28/06/2022 -> CO Forwards and CO FixedFloats are mostly similar. Unable to diff.
	//		else if IsCommodityForward( trade -> tradableProduct -> product ) then
	//            ExtractCounterpartyByRole(
	//                trade -> tradableProduct -> counterparty,
	//                CommodityLeg1( trade -> tradableProduct -> product ) only-element -> payerReceiver -> receiver )
			else if IsCapFloor( trade -> tradableProduct -> product ) then
				ExtractCounterpartyByRole(
					trade -> tradableProduct -> counterparty,
					trade -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> interestRatePayout only-element -> payerReceiver -> payer )
	set leiAndPerson:
			PartyLeiAndPersonByRoles(counterparty -> partyReference, partyInformation,[NaturalPersonRoleEnum->Buyer, NaturalPersonRoleEnum->Seller])

func CDEDirection1SellerIdentifier:
	[regulatoryReference CPMI_IOSCO CDE section "2" field "13" dataElement "1"
		rationale "Splitting definition into separate rules for Buyer and Seller"
		rationale_author "BNPP"
		rationale "Discussed on US Compliance WG - confirmed as per ISDA best practice for direction provided to CPMI-IOSCO best practice and CFTC tiebreaker logic  - Interest rate FRA  should be reported as payer/receiver."
		rationale_author "DRR US Compliance WG - 23/11/21"
		rationale "Peer review recommended to detect private individual party representations (instead of LEI scheme)."
		rationale_author "Peer Review WG - 07/03/2022"
   		provision "Identifier of the counterparty that is the buyer and the counterparty that is the seller, as determined at the time of the transaction.
			A non-exhaustive list of examples of instruments for which this data element could apply are:
				- most forwards and forward-like contracts (except for foreign exchange forwards and foreign exchange non-deliverable forwards)
				- most options and option-like contracts including swaptions, caps and floors
				- credit default swaps (buyer/seller of protection)
				- variance, volatility and correlation swaps
				- contracts for difference and spreadbets
			This data element is not applicable to instrument types covered by data elements Direction 2 or by Payer identifier and Receiver identifier."]
	inputs: trade Trade(1..1)
			partyInformation PartyInformation(1..*)
	output: leiAndPerson string (0..1)
	alias counterparty:
        if trade -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> optionPayout exists then
            ExtractCounterpartyByRole(
                trade -> tradableProduct -> counterparty,
                trade -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> optionPayout only-element -> buyerSeller -> seller )
        else if IsCreditDefaultSwap( trade -> tradableProduct -> product ) then
            ExtractCounterpartyByRole(
                trade -> tradableProduct -> counterparty,
                trade -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> payerReceiver -> payer )
        //TH Review -> should apply to all VOL/VAR/CORR swaps. Correlation pending
		else if IsVarianceSwap (trade -> tradableProduct -> product ) or IsVolatilitySwap (trade -> tradableProduct -> product ) then
			ExtractCounterpartyByRole(
                trade -> tradableProduct -> counterparty,
                trade -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> performancePayout only-element -> payerReceiver -> payer )
        // TH review -> for commodity forwards only. As of 28/06/2022 -> CO Forwards and CO FixedFloats are mostly similar. Unable to diff.
//		else if IsCommodityForward( trade -> tradableProduct -> product ) then
//            ExtractCounterpartyByRole(
//                trade -> tradableProduct -> counterparty,
//                CommodityLeg1( Product ) only-element -> payerReceiver -> payer )
        else if IsCapFloor( trade -> tradableProduct -> product ) then
            ExtractCounterpartyByRole(
                trade -> tradableProduct -> counterparty,
                trade -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> interestRatePayout only-element -> payerReceiver -> receiver )
        set leiAndPerson:
			PartyLeiAndPersonByRoles(counterparty -> partyReference, partyInformation,[NaturalPersonRoleEnum->Buyer, NaturalPersonRoleEnum->Seller])

reporting rule CDECleared <"Cleared">
    [regulatoryReference CPMI_IOSCO CDE section "2" field "14"
        provision "Indicator of whether the transaction has been cleared, or is intended to be cleared, by a central counterparty."]
	extract if IsCleared(ReportableEvent -> originatingWorkflowStep) = True then "Y"
		else if ReportableEvent -> originatingWorkflowStep -> nextEvent -> intent = EventIntentEnum -> Clearing then "I"
		else "N"
	as "2.14 Cleared"

reporting rule CDECentralCounterparty <"Central Counterparty">
	[regulatoryReference CPMI_IOSCO CDE section "2" field "15"
		provision "Identifier of the central counterparty (CCP) that cleared the transaction. This data element is not applicable if the value of the data element Cleared is N (No, not centrally cleared) or I (Intent to clear)."]
	filter when IsCleared(ReportableEvent -> originatingWorkflowStep) = True then
        extract ExtractPartyFromRelatedPartyByRole( ReportableEvent -> reportableInformation -> partyInformation -> relatedParty, PartyRoleEnum -> ClearingOrganization ) then
        extract PartyLei(Party -> partyId)

reporting rule CDEClearingMember<"Clearing Member">
    [regulatoryReference CPMI_IOSCO CDE section "2" field "16"
        provision "Identifier of the clearing member through which a derivative transaction was cleared at a central counterparty. This data element is applicable to cleared transactions under both the agency clearing model and the principal clearing model"]
    filter when IsCleared(ReportableEvent -> originatingWorkflowStep) = True then
	    extract ExtractPartyFromRelatedPartyByRole( ReportableEvent -> reportableInformation -> partyInformation -> relatedParty, PartyRoleEnum -> ClearingFirm ) then
		    extract Party -> partyId -> identifier
    as "2.16 Clearing member"

reporting rule CDEPlatformIdentifier
	[regulatoryReference CPMI_IOSCO CDE section "2" field "17"
   		provision "Identifier  of  the  trading  facility  (eg  exchange,  multilateral  trading  facility,  swap  execution facility) on which the transaction was executed."]
	extract TradeForEvent( ReportableEvent ) then
		extract if Trade -> executionDetails -> executionType = ExecutionTypeEnum -> Electronic
			then Trade -> executionDetails -> executionVenue -> entityId

reporting rule CDEConfirmed <"Confirmed">
    [regulatoryReference CPMI_IOSCO CDE section "2" field "18"
        provision "For new reportable transactions (as defined by the CPMI-IOSCO Technical Guidance: Harmonisation of the Unique Transaction Identifier), whether the legally binding terms of an OTC derivatives contract were documented and agreed upon (confirmed) or not (unconfirmed). If documented and agreed, whether such confirmation was done:  via a shared confirmation facility or platform, or a private/bilateral electronic system (electronic);  via a human-readable written document, such as fax, paper or manually processed e-mails (non-electronic)."]
	extract
	if ReportableEvent -> reportableInformation -> confirmationMethod = ConfirmationMethodEnum -> Electronic then "ECNF"
	else if ReportableEvent -> reportableInformation -> confirmationMethod = ConfirmationMethodEnum -> NonElectronic then "YCNF"
	else if ReportableEvent -> reportableInformation -> confirmationMethod = ConfirmationMethodEnum -> NotConfirmed then "NCNF"
	else ""

func CDEFinalContractualSettlementDate: <"Final Contractual Settlement Date">
   	[regulatoryReference CPMI_IOSCO CDE section "2" field "19"
   		provision "Unadjusted date as per the contract, by which all transfer of cash or assets should take place and the counterparties should no longer have any outstanding obligations to each other under that contract. For products that may not have a final contractual settlement date (eg American options), this data element reflects the date by which the transfer of cash or asset would take place if termination were to occur on the expiration date."]
    inputs: trade Trade (1..1)
    output: finalContractualSettlementDate date (0..1)
    alias product: trade -> tradableProduct -> product
    alias economicTerms: product -> contractualProduct -> economicTerms
    set finalContractualSettlementDate:
        /*if economicTerms -> terminationDate exists then
            economicTerms -> terminationDate -> adjustableDate -> unadjustedDate
        else if economicTerms -> payout -> optionPayout -> underlier -> contractualProduct -> economicTerms -> terminationDate exists then
            economicTerms -> payout -> optionPayout -> underlier -> contractualProduct -> economicTerms -> terminationDate -> adjustableDate -> unadjustedDate max*/
		if economicTerms -> payout -> optionPayout -> underlier -> contractualProduct -> economicTerms -> terminationDate exists then
            economicTerms -> payout -> optionPayout -> underlier -> contractualProduct -> economicTerms -> terminationDate -> adjustableDate -> unadjustedDate max
        // IR Swaption
        else if IsSwaption( product ) then
            UnderlierForProduct( product ) -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> calculationPeriodDates -> terminationDate -> adjustableDate -> unadjustedDate max
        // IRS
        else if Qualify_AssetClass_InterestRate_Swap( economicTerms ) then
            economicTerms -> payout -> interestRatePayout -> calculationPeriodDates -> terminationDate -> adjustableDate -> unadjustedDate max
        // CO Basis
        else if IsCommodityCommodity( product ) then
            economicTerms -> payout -> commodityPayout -> calculationPeriodDates -> terminationDate -> adjustableDate -> unadjustedDate max
        // CO using schedule
        else if IsCommodity( product ) then
            economicTerms -> payout -> commodityPayout -> schedule -> schedulePeriod -> paymentDate max
		// See CDEFinalSettlementDate_FXOption
        else if IsOption( product ) then
            economicTerms -> payout -> optionPayout -> settlementTerms -> cashSettlementTerms -> valuationDate -> valuationDate -> adjustedDate max
        // EQ Swaps
        else if economicTerms -> payout -> performancePayout count = 1 and product -> contractualProduct -> economicTerms -> payout -> interestRatePayout count = 1 then
            MaxTerminationDate (
                economicTerms -> payout -> performancePayout -> valuationDates -> valuationDatesFinal -> valuationDate -> adjustableDate only-element,
                economicTerms -> payout -> interestRatePayout -> calculationPeriodDates -> terminationDate -> adjustableDate only-element
            )
		//TH Review -> eq2perf update proposal : remove the prev "else if" statement completely. All EQ should report terminationDate at economicTerms level
		else if economicTerms -> terminationDate exists then
            economicTerms -> terminationDate -> adjustableDate -> unadjustedDate

reporting rule CDESettlementCurrency <"SettlementCurrency">
 	[regulatoryReference CPMI_IOSCO CDE section "2" field "20"
 		provision "Currency for the cash settlement of the transaction when applicable. For multicurrency products that do not net, the settlement currency of each leg. This data element is not applicable for physically settled products (eg physically settled swaptions)."]
 	extract if SettlementTerms -> settlementType = SettlementTypeEnum -> Cash or SettlementTerms -> cashSettlementTerms exists then
        CNHToCNY(SettlementTerms -> settlementCurrency)

reporting rule CDEDayCountConvention <"Day Count Convention">
	[regulatoryReference CPMI_IOSCO CDE section "2" field "22"
		rationale_author "DRR"
		rationale "Additional Day Count Fractions commented out will be inserted back in the model and in the reporting logic once evidence of business use cases and corresponding test data is made available, upon recommendation from ISDA CFTC DRR Peer Group."
		provision "For each leg of the transaction, where applicable: day count convention (often also referred to as day count fraction or day count basis or day count method) that determines how interest payments are calculated. It is used to compute the year fraction of the calculation period, and indicates the number of days in the calculation period divided by the number of days in the year. A001 = IC30360ISDAor30360AmericanBasicRule;A002 = IC30365;A003 = IC30Actual;A004 = Actual360;A005 = Actual365Fixed;A006 = ActualActualICMA;A007 = IC30E360orEuroBondBasismodel1;A008 = ActualActualISDA;A009 = Actual365LorActuActubasisRule; A010 = ActualActualAFB; A011 = IC30360ICMAor30360basicrule;A012 = IC30E2360orEurobondbasismodel2;A013 = IC30E3360orEurobondbasismodel3;A014 = Actual365NL;A015 = ActualActualUltimo;A016 = IC30EPlus360;A017 = Actual364;A018 = Business252;A019 = Actual360NL;A020 = 1/1;NARR = Narrative"]			
	extract
		if InterestRatePayout -> dayCountFraction = DayCountFractionEnum -> _30_360 then "A001" else
		//if InterestRatePayout -> dayCountFraction = DayCountFractionEnum -> IC_30_365 then "A002" else
		//if InterestRatePayout -> dayCountFraction = DayCountFractionEnum -> IC_30_Actual then "A003" else
		if InterestRatePayout -> dayCountFraction = DayCountFractionEnum -> ACT_360 then "A004" else //TO-DO Verify daycountFraction for Basis Swap
		if InterestRatePayout -> dayCountFraction = DayCountFractionEnum -> ACT_365_FIXED then "A005" else
		if InterestRatePayout -> dayCountFraction = DayCountFractionEnum -> ACT_ACT_ICMA then "A006" else
		if InterestRatePayout -> dayCountFraction = DayCountFractionEnum -> _30E_360_ISDA then "A007" else
		if InterestRatePayout -> dayCountFraction = DayCountFractionEnum -> ACT_ACT_ISDA then "A008" else
		if InterestRatePayout -> dayCountFraction = DayCountFractionEnum -> ACT_365L then "A009" else
		if InterestRatePayout -> dayCountFraction = DayCountFractionEnum -> ACT_ACT_AFB then "A010" else
		if InterestRatePayout -> dayCountFraction = DayCountFractionEnum -> _30E_360 then "A011" else
		//if InterestRatePayout -> dayCountFraction = DayCountFractionEnum -> IC_30_E2360_orEurobondbasismodel_2 then "A012" else
		//if InterestRatePayout -> dayCountFraction = DayCountFractionEnum -> IC_30_E3360_orEurobondbasismodel_3 then "A013" else
		//if InterestRatePayout -> dayCountFraction = DayCountFractionEnum -> ACT_365NL then "A014" else
		if InterestRatePayout -> dayCountFraction = DayCountFractionEnum -> ACT_ACT_ISMA then "A015" else
		//if InterestRatePayout -> dayCountFraction = DayCountFractionEnum -> 30E+_360 then "A016" else
		if InterestRatePayout -> dayCountFraction = DayCountFractionEnum -> ACT_364 then "A017" else
		if InterestRatePayout -> dayCountFraction = DayCountFractionEnum -> BUS_252 then "A018" else
		//if InterestRatePayout -> dayCountFraction = DayCountFractionEnum -> ACT_360NL then "A019" else
		if InterestRatePayout -> dayCountFraction = DayCountFractionEnum -> _1_1 then "A020" else
		if InterestRatePayout -> dayCountFraction exists then "NARR" else ""
	//above will yield "NARR" for all other daycounts until list is complete
	//TO-DO - Add logic to indentify origin of cashflow if its not unqiue

reporting rule CDEPaymentFrequencyPeriod <"Payment Frequency Period">
 	[regulatoryReference CPMI_IOSCO CDE section "2" field "23"
 		provision "For each leg of the transaction, where applicable: time unit associated with the frequency of payments, eg day, week, month, year or term of the stream"]
 	 //TODO: When aliasing is available, traverse full path
	 extract
        if InterestRatePayout -> paymentDates -> paymentFrequency -> period = PeriodExtendedEnum->D then  "DAIL"
        else if InterestRatePayout -> paymentDates -> paymentFrequency -> period = PeriodExtendedEnum->W then  "WEEK"
        else if InterestRatePayout -> paymentDates -> paymentFrequency -> period = PeriodExtendedEnum->M then  "MNTH"
        else if InterestRatePayout -> paymentDates -> paymentFrequency -> period = PeriodExtendedEnum->Y then  "YEAR"
        else if InterestRatePayout -> paymentDates -> paymentFrequency -> period = PeriodExtendedEnum->T then  "EXPI"

reporting rule CDEPaymentFrequencyPeriodMultiplier <"Payment Frequency Period Multiplier">
 	[regulatoryReference CPMI_IOSCO CDE section "2" field "24"
 		provision "For each leg of the transaction, where applicable: number of time units (as expressed by the payment frequency period) that determines the frequency at which periodic payment dates occur. For example, a transaction with payments occurring every two months is represented with a payment frequency period of MNTH (monthly) and a payment frequency period multiplier of 2. This data element is not applicable if the payment frequency period is ADHO. If payment frequency period is TERM, then the payment frequency period multiplier is 1. If the payment frequency is intraday, then the payment frequency period is DAIL and the payment frequency multiplier is 0."]
 	extract InterestRatePayout -> paymentDates -> paymentFrequency -> periodMultiplier

reporting rule CDEPrice <"Price">
    [regulatoryReference CPMI_IOSCO CDE section "2" dataElement "50" field "Price"
		provision "Price specified in the OTC derivative transaction. It does not include fees, taxes or commissions.
        For commodity fixed/float swaps and similar products with periodic payments, this data element refers to the fixed price of the fixed leg(s).
        For commodity and equity forwards and similar products, this data element refers to the forward price of the underlying or reference asset.
        For equity swaps, portfolios swaps, and similar products, this data element refers to the initial price of the underlying or reference asset.
        For contracts for difference and similar products, this data element refers to the initial price of the underlier.
        This data element is not applicable to:
            - Interest rate swaps and forward rate agreements, as it is understood that the information included in the data elements Fixed rate and Spread may be interpreted as the price of the transaction.
            - Interest rate options and interest rate swaptions, as it is understood that the information included in the data elements Strike price and Option premium may be interpreted as the price of the transaction.
            - Commodity basis swaps and the floating leg of commodity fixed/float swaps, as it is understood that the information included in the data element Spread may be interpreted as the price of the transaction.
            - Foreign exchange swaps, forwards and options, as it is understood that the information included in the data elements Exchange rate, Strike price, and Option premium may be interpreted as the price of the transaction.
            - Equity options, as it is understood that the information included in the data elements Strike price and Option premium may be interpreted as the price of the transaction.
            - Credit default swaps and credit total return swaps, as it is understood that the information included in the data elements Fixed rate, Spread and Upfront payment (Other payment type: Upfront payment) may be interpreted as the price of the transaction.
            - Commodity options, as it is understood that the information included in the data elements Strike price and Option premium may be interpreted as the price of the transaction. Where the price is not known when a new transaction is reported, the price is updated as it becomes available.
        For transactions that are part of a package, this data element contains the price of the component transaction where applicable."]
    extract Contract_Price_Monetary( ReportableEvent )
		// TODO: check all other types of price where this provision may be applicable (i.e. any "cash" price, but not Strike, Premium or Exchange Rate)
        then extract PriceSchedule -> amount
            as "2.50 Price"

reporting rule CDEPriceCurrency <"Price Currency">
	[regulatoryReference CPMI_IOSCO CDE section "2" field "51"
  		provision "Currency in which the price is denominated. Price currency is only applicable if Price notation = 1."]
	extract Contract_Price_Monetary( ReportableEvent )  then // To be updated according to CDEPrice (when non-Monetary)
		extract if IsPriceMonetary( PriceSchedule )
			then PriceSchedule -> unitOfAmount -> currency

reporting rule CDEPriceNotation <"Price Notation">
	[regulatoryReference CPMI_IOSCO CDE section "2" field "52"
		provision "Manner in which the price is expressed."]
	extract Contract_Price_Monetary( ReportableEvent )  then // To be updated according to CDEPrice (when non-Monetary)
		extract if IsPriceMonetary( PriceSchedule )
			then "1"
			else "3"

reporting rule CDEPriceUnitOfMeasure <"Price Unit Of Measure">
	[regulatoryReference CPMI_IOSCO CDE section "2" field "53"
		provision "Unit of measure in which the price is expressed."]
	extract Contract_Price_Monetary( ReportableEvent )  then
		extract 
			if PriceSchedule -> perUnitOfAmount -> capacityUnit exists then
				CapacityUnitToISO20022UnitOfMeasure (PriceSchedule -> perUnitOfAmount -> capacityUnit)
			else if PriceSchedule -> perUnitOfAmount -> weatherUnit exists then
				WeatherUnitToISO20022UnitOfMeasure (PriceSchedule -> perUnitOfAmount -> weatherUnit)
			else if PriceSchedule -> perUnitOfAmount -> financialUnit exists then
				FinancialUnitToISO20022UnitOfMeasure (PriceSchedule -> perUnitOfAmount -> financialUnit)
			else if PriceSchedule -> priceExpression -> priceType = PriceTypeEnum -> InterestRate then
				"----"
func CDEInterestRateFixedRate: <"Fixed Rate for Interest Rates">
	[regulatoryReference CPMI_IOSCO CDE section "2" field "55"
		provision "For each leg of the transaction, where applicable: for OTC derivative transactions with periodic payments, per annum rate of the fixed leg(s)."]
	inputs: interestRatePayout InterestRatePayout (0..1)
	output: amount number (0..1)
	set amount:
		interestRatePayout -> rateSpecification -> fixedRate -> rateSchedule -> price -> amount

func CDEFixedPriceFixedRate: <"Fixed Rate for Fixed Forwards">
	inputs: fixedPricePayout FixedPricePayout (0..1)
	output: amount number (0..1)
	set amount:
		fixedPricePayout -> fixedPrice -> price -> amount

func CDESpread_InterestRate: <"Spread (from InterestRatePayout)">
	inputs: interestRatePayout InterestRatePayout (0..1)
	output: spreadSchedule SpreadSchedule (0..1)
	set spreadSchedule:
		interestRatePayout -> rateSpecification -> floatingRate -> spreadSchedule

func CDESpread_Commodity: <"Spread (from CommodityPayout)">
	inputs: commodityPayout CommodityPayout (0..1)
	output: spread SpreadSchedule (0..1)
	set spread: commodityPayout -> commodityPriceReturnTerms -> spread

//TH Review -> waiting until syntax update
/*
reporting rule CDEInterestRateFixedRate <"Fixed Rate for Interest Rates">
	[regulatoryReference CPMI_IOSCO CDE section "2" field "55"
		provision "For each leg of the transaction, where applicable: for OTC derivative transactions with periodic payments, per annum rate of the fixed leg(s)."]
	extract InterestRatePayout -> rateSpecification -> fixedRate -> rateSchedule -> price -> amount

reporting rule CDEFixedPriceFixedRate <"Fixed Rate for Fixed Forwards">
    extract FixedPricePayout -> fixedPrice -> price -> amount

reporting rule CDESpread_InterestRate <"Spread (from InterestRatePayout)">
	filter when InterestRatePayout -> rateSpecification -> floatingRate exists then
		extract InterestRatePayout -> rateSpecification -> floatingRate -> spreadSchedule
			as "Spread (from InterestRatePayout)"

reporting rule CDESpread_Commodity <"Spread (from CommodityPayout)">
	extract CommodityPayout -> commodityPriceReturnTerms -> spread
		as "Spread (from CommodityPayout)"
*/

//TH Review -> This rule is not complete. There is no leg determination at input
reporting rule CDESpread <"Spread">
	[regulatoryReference CPMI_IOSCO CDE section "2" field "57"
		rationale "Spread is not applicable to an Inflation leg so inflation is not included in the logic of the code."
		rationale_author "DRR Peer Review Group - 08/03/22"
		provision "For each leg of the transaction, where applicable: for OTC derivative transactions with periodic payments (eg interest rate fixed/float swaps, interest rate basis swaps, commodity swaps), spread on the individual floating leg(s) index reference price, in the case where there is a spread on a floating leg(s). For example, USD-LIBOR-BBA plus .03 or WTI minus USD 14.65; difference between the reference prices of the two floating leg indexes. For example, the 9.00 USD Spread for a WCS vs. WTI basis swap where WCS is priced at 43 USD and WTI is priced at 52 USD."]
	extract if Payout -> interestRatePayout exists then CDESpread_InterestRate( Payout -> interestRatePayout only-element )
		else if Payout -> commodityPayout exists then CDESpread_Commodity( Payout -> commodityPayout only-element)

/*
reporting rule CDESpread <"Spread">
	[regulatoryReference CPMI_IOSCO CDE section "2" field "57"
		rationale "Spread is not applicable to an Inflation leg so inflation is not included in the logic of the code."
		rationale_author "DRR Peer Review Group - 08/03/22"
		provision "For each leg of the transaction, where applicable: for OTC derivative transactions with periodic payments (eg interest rate fixed/float swaps, interest rate basis swaps, commodity swaps), spread on the individual floating leg(s) index reference price, in the case where there is a spread on a floating leg(s). For example, USD-LIBOR-BBA plus .03 or WTI minus USD 14.65; difference between the reference prices of the two floating leg indexes. For example, the 9.00 USD Spread for a WCS vs. WTI basis swap where WCS is priced at 43 USD and WTI is priced at 52 USD."]
	(
		filter when Payout -> interestRatePayout exists then extract Payout -> interestRatePayout then CDESpread_InterestRate,
		filter when Payout -> commodityPayout exists then extract Payout -> commodityPayout then CDESpread_Commodity
	)
*/

reporting rule CDEStrikePrice <"Strike Price">
    [regulatoryReference CPMI_IOSCO CDE section "2" field "60"
		rationale "For variance swaps, the volatility strike price can be included as part of the product in CDM. The assumption in DRR is that volatility strike price must be reported for variance swaps."
		rationale_author "Peer Review Group - 2022-06-15"
        provision "For options other than FX options, swaptions and similar products, price at which the owner of an option can buy or sell the underlying asset of the option. For foreign exchange options, exchange rate at which the option can be exercised, expressed as the rate of exchange from converting the unit currency into the quoted currency. In the example 0.9426 USD/EUR, USD is the unit currency and EUR is the quoted currency; USD 1 = EUR 0.9426.Where the strike price is not known when a new transaction is reported, the strike price is updated as it becomes available.  For volatility and variance swaps and similar products the volatility strike price is reported in this data element."]
	extract Contract_StrikePrice( ReportableEvent )

reporting rule CDEStrikePriceCurrency <"Strike price currency/currency pair">
    [regulatoryReference CPMI_IOSCO CDE section "2" field "61"
        provision "For equity options, commodity options, and similar products, currency in which the strike price is denominated. For foreign exchange options: Currency pair and order in which the strike price is expressed. It is expressed as unit currency/quoted currency. In the example 0.9426 USD/EUR, USD is the unit currency and EUR is the quoted currency, USD 1 = EUR 0.9426 Strike price currency/currency pair is only applicable if Strike price notation = 1."]
	extract Contract_StrikePrice( ReportableEvent ) then
		filter when IsPriceMonetary(PriceSchedule) then //TH Review
		extract
		(
			if PriceSchedule -> priceExpression -> priceType = PriceTypeEnum -> ExchangeRate
				and PriceSchedule -> perUnitOfAmount -> currency exists
			    and PriceSchedule -> unitOfAmount -> currency exists
			then PriceSchedule -> perUnitOfAmount -> currency + "/" + PriceSchedule -> unitOfAmount -> currency
			else PriceSchedule -> unitOfAmount -> currency
		)

reporting rule CDEStrikePriceNotation <"Strike Price Notation">
	[regulatoryReference CPMI_IOSCO CDE section "2" field "62"
		provision "Manner in which the strike price is expressed"]
	extract Contract_StrikePrice( ReportableEvent )
	then extract
		if IsPriceMonetary( PriceSchedule )
		//if PriceSchedule -> perUnitOfAmount -> currency is absent or PriceSchedule -> unitOfAmount -> currency <> PriceSchedule -> perUnitOfAmount -> currency
		then "1"
		else "3"
	
reporting rule CDEOptionPremiumAmount <"Option Premium Amount">
  	[regulatoryReference CPMI_IOSCO CDE section "2" field "64"
  		provision "For options and swaptions of all asset classes, monetary amount paid by the option buyer. This data element is not applicable if the instrument is not an option or does not embed any optionality."]
	extract TradeStateForEvent( ReportableEvent ) then
	    extract TradeState -> transferHistory then
			filter when TransferState -> transfer -> transferExpression -> priceTransfer = FeeTypeEnum -> Premium then
				extract TransferState -> transfer -> quantity -> amount

reporting rule CDEOptionPremiumCurrency <"Option Premium Currency">
  	[regulatoryReference CPMI_IOSCO CDE section "2" field "65"
  		provision "For options and swaptions of all asset classes, currency in which the option premium amount is denominated. This data element is not applicable if the instrument is not an option or does not embed any optionality."]
	extract TradeStateForEvent( ReportableEvent ) then
	    extract TradeState -> transferHistory then
		filter when TransferState -> transfer -> transferExpression -> priceTransfer = FeeTypeEnum -> Premium then
		extract TransferState -> transfer -> quantity -> unitOfAmount -> currency

reporting rule CDEOptionPremiumPaymentDate <"Option Premium Payment Date">
	[regulatoryReference CPMI_IOSCO CDE section "2" field "66"
		provision "Unadjusted date on which the option premium is paid."]
	extract TradeStateForEvent( ReportableEvent ) then
	    extract TradeState -> transferHistory then
		filter when TransferState -> transfer -> transferExpression -> priceTransfer = FeeTypeEnum -> Premium then
		extract TransferState -> transfer -> settlementDate -> unadjustedDate
		// TODO: handle other cases of settlement dates, e.g. when expressed as a relative date instead - what should be the "unadjusted date" in this case?

reporting rule CDEFirstExerciseDate
	[regulatoryReference CPMI_IOSCO CDE section "2" field "67"
		provision "First unadjusted date during the exercise period in which an option can be exercised.
			For European-style options, this date is same as the Expiration date. For American-style options,
			the first possible exercise date is the unadjusted date included in the execution timestamp.
			For knock-in options, where the first exercise date is not known when a new transaction is
			reported, the first exercise date is updated as it becomes available.
			This data element is not applicable if the instrument is not an option or does not embed any
			optionality."]
	extract
		if OptionStyle -> americanExercise exists
			then OptionStyle -> americanExercise -> commencementDate -> adjustableDate -> unadjustedDate
        else if OptionStyle -> europeanExercise exists
            then OptionStyle -> europeanExercise -> expirationDate -> adjustableDate -> unadjustedDate min
        else if OptionStyle -> bermudaExercise exists
            then OptionStyle -> bermudaExercise -> bermudaExerciseDates -> adjustableDates -> unadjustedDate min


func CDEEquityTotalNotionalQuantity:
    inputs:
        trade Trade (1..1)
    output:
        result number (1..1)

    //alias economicTerms : product -> contractualProduct -> economicTerms

    alias quantity:
        /*if economicTerms -> payout -> performancePayout exists
            then economicTerms -> payout -> performancePayout only-element -> priceQuantity -> quantitySchedule-> amount
        else if  economicTerms -> payout -> optionPayout -> underlier -> security exists and economicTerms -> payout -> optionPayout -> priceQuantity -> quantitySchedule -> multiplier exists
            then GetProduct(economicTerms -> payout -> optionPayout -> priceQuantity -> quantitySchedule -> amount only-element,economicTerms -> payout -> optionPayout -> priceQuantity -> quantitySchedule -> multiplier only-element)
        else if economicTerms -> payout -> optionPayout -> underlier -> security exists
            then economicTerms -> payout -> optionPayout -> priceQuantity -> quantitySchedule -> amount only-element
        else if economicTerms -> payout -> optionPayout -> underlier -> index exists and economicTerms -> payout -> optionPayout -> priceQuantity -> quantitySchedule -> multiplier exists
            then GetProduct(economicTerms -> payout -> optionPayout -> priceQuantity -> quantitySchedule -> amount only-element,economicTerms -> payout -> optionPayout -> priceQuantity -> quantitySchedule -> multiplier only-element)
        else if economicTerms -> payout -> optionPayout -> underlier -> index exists then economicTerms -> payout -> optionPayout -> priceQuantity -> quantitySchedule -> amount only-element*/
		if IsEquityOption(ProductForTrade(trade)) and ProductForTrade(trade) -> contractualProduct -> economicTerms -> payout -> optionPayout -> priceQuantity -> quantitySchedule -> unitOfAmount -> currency exists then
			trade -> tradableProduct -> tradeLot -> priceQuantity -> quantity
			filter [item -> unitOfAmount -> financialUnit exists and item -> unitOfAmount -> financialUnit <> FinancialUnitEnum -> Contract] only-element
		else if IsEquityOption(ProductForTrade(trade)) and ProductForTrade(trade) -> contractualProduct -> economicTerms -> payout -> optionPayout -> priceQuantity -> quantitySchedule -> unitOfAmount -> financialUnit exists then
			ProductForTrade(trade) -> contractualProduct -> economicTerms -> payout -> optionPayout -> priceQuantity -> quantitySchedule only-element
	
	set result:
		quantity -> amount

func CDECommodityTotalNotionalQuantity:
	inputs:
		commodityPayout CommodityPayout (1..1)
	output:
		result number (1..1)

	set result:
		commodityPayout -> priceQuantity -> quantitySchedule -> amount

func CDEFixedPriceTotalNotionalQuantity:
	inputs:
		fixedPricePayout FixedPricePayout (1..1)
	output:
		result number (1..1)

	set result:
		fixedPricePayout -> priceQuantity -> quantitySchedule -> amount

//TH review: Once the type resolution issue is solved. This function won't be needed.
func GetProduct:
	inputs:
		multiplier number (1..1)
		quant number (1..1)
	output:
		product number (1..1)
	set product:
		multiplier * quant

reporting rule CDEExchangeRate <"Exchange Rate">
  	[regulatoryReference CPMI_IOSCO CDE section "2" field "68"
  		provision "Exchange rate between the two different currencies specified in the OTC derivative transaction agreed by the counterparties at the inception of the transaction, expressed as the rate of exchange from converting the unit currency into the quoted currency. In the example 0.9426 USD/EUR, USD is the unit currency and EUR is the quoted currency; USD 1 = EUR 0.9426."]
    //Input stream is of CDM type ReportableEvent
	// OR condition between contract pricing model and strike price model in case of options
	(
		extract Contract_Price( ReportableEvent ),
		extract Contract_StrikePrice( ReportableEvent )
	) then
	//for all returned prices, filter the one of type ExchangeRate
	filter when PriceSchedule -> priceExpression -> priceType = PriceTypeEnum -> ExchangeRate as "2.68 Exchange Rate Price"

reporting rule CDEExchangeRateBasis <"Exchange Rate Basis">
    [regulatoryReference CPMI_IOSCO CDE section "2" field "69"
		rationale "Per CDE definition 0.9426 EUR (CDM unitOfAmount) per 1 USD (CDM perUnitOfAmount) should be expressed as USD/EUR"
        provision "Currency pair and order in which the exchange rate is denominated, expressed as unit currency/quoted currency. In the example 0.9426 USD/EUR, USD is the unit currency and EUR is the quoted currency, USD 1 = EUR 0.9426."]
		//Input stream is of CDM type Price
		//Only allow prices containing unit currency & quoted currency
        filter when PriceSchedule -> perUnitOfAmount -> currency exists then
        	filter when PriceSchedule -> unitOfAmount -> currency exists then
				extract (PriceSchedule -> perUnitOfAmount -> currency) + "/" + (PriceSchedule -> unitOfAmount -> currency)
        as "2.69 Exchange Rate Basis"

func CDENotional: <"Notional">
    [regulatoryReference CPMI_IOSCO CDE section "2" field "70"
        rationale "See separate CDEInterestRateNotional and CDEFXNotional which is required due to jurisdictional specific leg level ordering.  When ordering rules are harmonised they could be combined with CDE rules"
        rationale_author "DRR - Nigel Cobb - 28/7/21"
        provision "For each leg of the transaction, where applicable: - for OTC derivative transactions negotiated in monetary amounts, amount specified in the contract. - for OTC derivative transactions negotiated in non-monetary amounts:"]
    inputs: trade Trade (0..1)
    output: amount number (0..1)
    set amount:
        if trade -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> optionPayout -> underlier -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout exists
            then trade -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> optionPayout only-element -> underlier -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> priceQuantity -> quantitySchedule -> amount

        else if trade -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout exists
            then trade -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> priceQuantity -> quantitySchedule -> amount

        //TH -> eq2perf update proposal
        /*else if Trade -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> performancePayout -> priceQuantity -> quantitySchedule count = 1
            then  Trade -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> performancePayout -> priceQuantity -> quantitySchedule -> amount

        else if Trade -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> optionPayout -> priceQuantity -> quantitySchedule exists
        and  Trade -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> optionPayout -> underlier -> security -> securityType any = SecurityTypeEnum -> Debt
            then Trade -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> optionPayout -> priceQuantity -> quantitySchedule -> amount
    
        else if Trade -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> optionPayout -> priceQuantity -> quantitySchedule exists
        and  Trade -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> optionPayout -> underlier -> security -> securityType any = SecurityTypeEnum -> Equity
            then Trade -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> optionPayout -> priceQuantity -> quantitySchedule -> amount*/

        else if Qualify_Commodity_Swap_FixedFloat(trade -> tradableProduct -> product -> contractualProduct -> economicTerms)
            then CommodityLeg1 (trade -> tradableProduct -> product) -> priceQuantity -> quantitySchedule -> amount * FixedPriceLeg2(trade -> tradableProduct -> product) -> fixedPrice -> price -> amount
    
        else if Qualify_Commodity_Option( trade -> tradableProduct -> product -> contractualProduct -> economicTerms) then trade -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> optionPayout only-element -> exerciseTerms -> strike -> strikePrice -> amount * trade -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> optionPayout -> priceQuantity -> quantitySchedule -> amount

    //TH Comment: This following logic for Commodity Basis is not correct, but at this moment we do not have acces to the last available spot price of the underlying asset
    //else if Qualify_Commodity_Swap_Basis(Trade -> tradableProduct -> product -> contractualProduct -> economicTerms)
        //  filter when Trade -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> commodityPayout -> commodityPriceReturnTerms -> spread exists
    //  then extract Trade -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> commodityPayout -> priceQuantity -> resolvedQuantity -> amount * Trade -> tradableProduct -> tradeLot -> priceQuantity -> price -> amount

        else if IsEquityOption( trade -> tradableProduct -> product ) then
            trade -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> optionPayout only-element-> exerciseTerms -> strike -> strikePrice -> amount * trade -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> optionPayout -> priceQuantity -> quantitySchedule -> amount

func CDECommodityNotional: <"Commodity Notional">
	[regulatoryReference CPMI_IOSCO CDE section "2" field "70"
	provision "For each leg of the transaction, where applicable: - for OTC derivative transactions negotiated in monetary amounts, amount specified in the contract. - for OTC derivative transactions negotiated in non-monetary amounts:
			- Commodity fixed/float swaps and similar products: Product of the fixed price and the total notional quantity.
			- Commodity basis swaps and similar products: Product of the last available spot price at the time of the transaction of the underlying asset of the leg with no spread and the total notional quantity of the leg with no spread."]
	//TH review - review the calculation/extraction of the amount (CR-09/08/2022)
	inputs: quantity number (0..1)
			price number (0..1)
	output: amount number (0..1)
	set amount:
		price * quantity

func CDEOptionNotional:
	[regulatoryReference CPMI_IOSCO CDE section "2" field "70"
	provision "For each leg of the transaction, where applicable: - for OTC derivative transactions negotiated in monetary amounts, amount specified in the contract. - for OTC derivative transactions negotiated in non-monetary amounts:
			- Equity options and similar products: Product of the strike price and the number of shares or index units.
			- Commodity options and similar products: Product of the strike price, and the total notional quantity."]
	inputs: optionPayout OptionPayout (0..1)
	output: amount number (0..1)
	set amount:
		optionPayout -> priceQuantity -> quantitySchedule -> amount

func CDECommodityOptionNotional:
	[regulatoryReference CPMI_IOSCO CDE section "2" field "70"
	provision "For each leg of the transaction, where applicable: - for OTC derivative transactions negotiated in monetary amounts, amount specified in the contract. - for OTC derivative transactions negotiated in non-monetary amounts:
			- Equity options and similar products: Product of the strike price and the number of shares or index units.
			- Commodity options and similar products: Product of the strike price, and the total notional quantity."]
	inputs: optionPayout OptionPayout (0..1)
	output: amount number (0..1)
	set amount:
		optionPayout -> exerciseTerms -> strike -> strikePrice -> amount * optionPayout -> priceQuantity -> quantitySchedule -> amount

func CDEPerformanceNotional: <"Commodity Notional">
 	[regulatoryReference CPMI_IOSCO CDE section "2" field "70"
    		provision "For each leg of the transaction, where applicable: - for OTC derivative transactions negotiated in monetary amounts, amount specified in the contract. - for OTC derivative transactions negotiated in non-monetary amounts:
				- Equity variance swaps and similar products: Variance amount."]
	inputs: performancePayout PerformancePayout(0..*)
	output: amount number (0..1)
	set amount:
		//TH -> eq2perf update proposal
		if performancePayout -> priceQuantity -> quantitySchedule count = 1
			then performancePayout only-element -> priceQuantity -> quantitySchedule -> amount
	
func CDECreditNotional: <"Commodity Notional">
 	[regulatoryReference CPMI_IOSCO CDE section "2" field "70"
    		provision "For each leg of the transaction, where applicable: - for OTC derivative transactions negotiated in monetary amounts, amount specified in the contract. - for OTC derivative transactions negotiated in non-monetary amounts:"]
	inputs: creditDefaultPayout CreditDefaultPayout (0..1)
	output: amount number (0..1)
	set amount:
		creditDefaultPayout -> priceQuantity -> quantitySchedule -> amount

func CDEInterestRateNotional: <"Interest Rate Notional">
   	[regulatoryReference CPMI_IOSCO CDE section "2" field "70"
		rationale "CDEInterestRateNotional is required due to jurisdictional specific leg level ordering.  When ordering rules are harmonised they could be combined with CDE rules"
		rationale_author "DRR - Nigel Cobb - 28/7/21"
   		provision "For each leg of the transaction, where applicable: - for OTC derivative transactions negotiated in monetary amounts, amount specified in the contract. - for OTC derivative transactions negotiated in non-monetary amounts:"]
	inputs: interestRatePayout InterestRatePayout (0..1)
	output: amount number (0..1)
	set amount:
   		// Non-Monetary amounts - and potential subdivision - to be tackled in future
			if interestRatePayout -> priceQuantity -> quantitySchedule exists
				then interestRatePayout -> priceQuantity -> quantitySchedule -> amount

func CDEFXNotional: <"Interest Rate Notional">
   	[regulatoryReference CPMI_IOSCO CDE section "2" field "70"
		rationale "CDEFXNotional is required due to jurisdictional specific leg level ordering.  When ordering rules are harmonised they could be combined with CDE rules"
		rationale_author "DRR - Nigel Cobb - 28/7/21"
   		provision "For each leg of the transaction, where applicable: - for OTC derivative transactions negotiated in monetary amounts, amount specified in the contract. - for OTC derivative transactions negotiated in non-monetary amounts:"]
	inputs: quantity NonNegativeQuantitySchedule (0..1)
	output: amount number (0..1)
	set amount:
		quantity -> amount

reporting rule CDECallAmount <"Call Amount">
    [regulatoryReference CPMI_IOSCO CDE section "2" field "72"
        rationale_author "DRR-BlackRock"
        rationale "The Call Amount can be determined as the currency amount being received by the buyer of the option"]
    (
        extract TradeForEvent( ReportableEvent ) then 
            filter when Qualify_Commodity_Option( Trade -> tradableProduct -> product -> contractualProduct -> economicTerms) then 
                extract ProductForTrade( Trade ) then 
                    filter when IsCallOption( Product ) then
                        extract Product -> contractualProduct -> economicTerms -> payout -> optionPayout -> priceQuantity -> quantitySchedule -> amount * Product -> contractualProduct -> economicTerms -> payout -> optionPayout -> exerciseTerms -> strike -> strikePrice -> amount
        ,
		// Equity options with monetary quantity schedule
        extract TradeForEvent( ReportableEvent ) then 
            filter when IsEquityOption( Trade -> tradableProduct -> product ) then 
            extract ProductForTrade( Trade ) then filter when IsCallOption( Product ) and Product -> contractualProduct -> economicTerms -> payout -> optionPayout -> priceQuantity -> quantitySchedule -> unitOfAmount -> currency exists  then
        extract Product -> contractualProduct -> economicTerms -> payout -> optionPayout -> priceQuantity -> quantitySchedule -> amount
		,
		// Equity options with non-monetary quantity schedule
        extract TradeForEvent( ReportableEvent ) then 
            filter when IsEquityOption( Trade -> tradableProduct -> product ) then 
            extract ProductForTrade( Trade ) then filter when IsCallOption( Product ) and Product -> contractualProduct -> economicTerms -> payout -> optionPayout -> priceQuantity -> quantitySchedule -> unitOfAmount -> financialUnit exists  then
        extract Product -> contractualProduct -> economicTerms -> payout -> optionPayout -> priceQuantity -> quantitySchedule -> amount * Product -> contractualProduct -> economicTerms -> payout -> optionPayout -> exerciseTerms -> strike -> strikePrice -> amount
    ,
        CDECallQuantity then 
            extract NonNegativeQuantitySchedule -> amount
    )

reporting rule CDEPutAmount <"Put Amount">
    [regulatoryReference CPMI_IOSCO CDE section "2" field "73"
        rationale_author "DRR-REGnosys"
        rationale "The Put Amount can be determined as the currency amount being paid by the buyer of the option"
        provision "For foreign exchange options, the monetary amount that the option gives the right to sell."]
    (
        extract TradeForEvent( ReportableEvent ) then 
            filter when Qualify_Commodity_Option( Trade -> tradableProduct -> product -> contractualProduct -> economicTerms) then 
                extract ProductForTrade( Trade ) then 
                    filter when IsPutOption( Product ) then
                        extract Product -> contractualProduct -> economicTerms -> payout -> optionPayout -> priceQuantity -> quantitySchedule -> amount * Product -> contractualProduct -> economicTerms -> payout -> optionPayout -> exerciseTerms -> strike -> strikePrice -> amount
        ,
		// Equity options with monetary quantity schedule
        extract TradeForEvent( ReportableEvent ) then 
            filter when IsEquityOption( Trade -> tradableProduct -> product ) then 
            extract ProductForTrade( Trade ) then filter when IsPutOption( Product ) and Product -> contractualProduct -> economicTerms -> payout -> optionPayout -> priceQuantity -> quantitySchedule -> unitOfAmount -> currency exists  then
        extract Product -> contractualProduct -> economicTerms -> payout -> optionPayout -> priceQuantity -> quantitySchedule -> amount
		,
		// Equity options with non-monetary quantity schedule
        extract TradeForEvent( ReportableEvent ) then 
            filter when IsEquityOption( Trade -> tradableProduct -> product ) then 
            extract ProductForTrade( Trade ) then filter when IsPutOption( Product ) and Product -> contractualProduct -> economicTerms -> payout -> optionPayout -> priceQuantity -> quantitySchedule -> unitOfAmount -> financialUnit exists  then
        extract Product -> contractualProduct -> economicTerms -> payout -> optionPayout -> priceQuantity -> quantitySchedule -> amount * Product -> contractualProduct -> economicTerms -> payout -> optionPayout -> exerciseTerms -> strike -> strikePrice -> amount
    ,
        CDEPutQuantity then 
            extract NonNegativeQuantitySchedule -> amount
    )

func CDENotionalCurrency:
    [regulatoryReference CPMI_IOSCO CDE section "2" field "74"
        rationale "See separate CDEInterestRateNotionalCurrency and CDEFXNotionalCurrency which is required due to jurisdictional specific leg level ordering.  When ordering rules are harmonised they could be combined with CDE rules"
        rationale_author "DRR - Nigel Cobb - 28/7/21"
        provision "For each leg of the transaction, where applicable: currency in which the notional amount is denominated."]
    inputs: trade Trade (0..1)
    output: currency string (0..1)
    set currency: 
    if trade -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> optionPayout -> underlier -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout exists
            then trade -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> optionPayout only-element -> underlier -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> priceQuantity -> quantitySchedule -> unitOfAmount -> currency
            
        else if trade -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout exists
            then trade -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> priceQuantity -> quantitySchedule -> unitOfAmount -> currency

        /*else if Trade -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> equityPayout count = 1
            then Trade -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> equityPayout -> priceQuantity -> quantitySchedule -> unitOfAmount -> currency*/

        //TH -> eq2perf update proposal
        else if trade -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> performancePayout count = 1
                    then trade -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> performancePayout only-element -> priceQuantity -> quantitySchedule -> unitOfAmount -> currency

        //TH Review -> are Vol/Var swaps single leg products?
        else if trade -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> performancePayout count = 1
            then trade -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> performancePayout only-element -> priceQuantity -> quantitySchedule -> unitOfAmount -> currency

        /*else if Trade -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> optionPayout -> priceQuantity -> quantitySchedule exists
            and  Trade -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> optionPayout -> underlier -> security -> securityType any = SecurityTypeEnum -> Debt
            then Trade -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> optionPayout -> priceQuantity -> quantitySchedule -> unitOfAmount -> currency
        
        else if Trade -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> optionPayout -> priceQuantity -> quantitySchedule exists
            and  Trade -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> optionPayout -> underlier -> security -> securityType any = SecurityTypeEnum -> Equity
            then Trade -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> optionPayout -> priceQuantity -> quantitySchedule -> unitOfAmount -> currency*/

        else if Qualify_Commodity_Swap_FixedFloat( trade -> tradableProduct -> product -> contractualProduct -> economicTerms) then
            FixedPriceLeg2(trade -> tradableProduct -> product) -> fixedPrice -> price -> unitOfAmount -> currency

        else if Qualify_Commodity_Option( trade -> tradableProduct -> product -> contractualProduct -> economicTerms) then ProductForTrade(trade) -> contractualProduct -> economicTerms -> payout -> optionPayout only-element -> exerciseTerms -> strike -> strikePrice -> unitOfAmount -> currency
        
        else if IsEquityOption( trade -> tradableProduct -> product ) then
            trade -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> optionPayout only-element -> exerciseTerms -> strike -> strikePrice -> unitOfAmount -> currency

func CDECommodityNotionalCurrency:
	[regulatoryReference CPMI_IOSCO CDE section "2" field "74"
		provision "For each leg of the transaction, where applicable: currency in which the notional amount is denominated."]
	inputs: price PriceSchedule (0..1)
	output: currency string (0..1)
	set currency:
		price -> unitOfAmount -> currency		

func CDEOptionNotionalCurrency: 
[regulatoryReference CPMI_IOSCO CDE section "2" field "74"
		provision "For each leg of the transaction, where applicable: currency in which the notional amount is denominated."]
	inputs: optionPayout OptionPayout (0..1)
	output: currency string (0..1)
	set currency: 
			optionPayout -> exerciseTerms -> strike -> strikePrice -> unitOfAmount -> currency

func CDEPerformanceNotionalCurrency:
	[regulatoryReference CPMI_IOSCO CDE section "2" field "74"
		provision "For each leg of the transaction, where applicable: currency in which the notional amount is denominated."]
	inputs: performancePayout PerformancePayout (0..*)
	output: currency string (0..1)
	set currency:
		/*else if Trade -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> equityPayout count = 1
			then Trade -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> equityPayout -> priceQuantity -> quantitySchedule -> unitOfAmount -> currency*/
		//TH -> eq2perf update proposal
		if performancePayout count = 1 then performancePayout only-element -> priceQuantity -> quantitySchedule -> unitOfAmount -> currency
		//TH Review -> are Vol/Var swaps single leg products?
		else if performancePayout count = 1 then performancePayout only-element -> priceQuantity -> quantitySchedule -> unitOfAmount -> currency

func CDECreditNotionalCurrency:
	[regulatoryReference CPMI_IOSCO CDE section "2" field "74"
		provision "For each leg of the transaction, where applicable: currency in which the notional amount is denominated."]
	inputs: creditDefaultPayout CreditDefaultPayout (0..1)
	output: currency string (0..1)
	set currency:
		creditDefaultPayout -> priceQuantity -> quantitySchedule -> unitOfAmount -> currency

func CDEInterestRateNotionalCurrency:
	[regulatoryReference CPMI_IOSCO CDE section "2" field "74"
		rationale "CDEInterestRateNotionalCurrency is required due to jurisdictional specific leg level ordering.  When ordering rules are harmonised they could be combined with CDE rules"
		rationale_author "DRR - Nigel Cobb - 28/7/21"
		provision "For each leg of the transaction, where applicable: currency in which the notional amount is denominated."]
	inputs: interestRatePayout InterestRatePayout (0..1)
	output: currency string (0..1)
    set currency:
		if interestRatePayout -> priceQuantity -> quantitySchedule exists
			then interestRatePayout -> priceQuantity -> quantitySchedule -> unitOfAmount -> currency
		else if interestRatePayout -> priceQuantity -> quantityReference exists
			then interestRatePayout -> priceQuantity -> quantityReference -> quantitySchedule -> unitOfAmount -> currency

func CDEFXNotionalCurrency:
	[regulatoryReference CPMI_IOSCO CDE section "2" field "74"
		rationale "CDEFXNotionalCurrency is required due to jurisdictional specific leg level ordering.  When ordering rules are harmonised they could be combined with CDE rules"
		rationale_author "DRR - Nigel Cobb - 28/7/21"
		provision "For each leg of the transaction, where applicable: currency in which the notional amount is denominated."]
	inputs: quantity NonNegativeQuantitySchedule (0..1)
	output: currency string (0..1)
	set currency:
    	quantity -> unitOfAmount -> currency

//TH Review -> should not delete until syntax update revision
/*
reporting rule CDENotional <"Notional">
	[regulatoryReference CPMI_IOSCO CDE section "2" field "70"
		rationale "See separate CDEInterestRateNotional and CDEFXNotional which is required due to jurisdictional specific leg level ordering.  When ordering rules are harmonised they could be combined with CDE rules"
		rationale_author "DRR - Nigel Cobb - 28/7/21"
   		provision "For each leg of the transaction, where applicable: - for OTC derivative transactions negotiated in monetary amounts, amount specified in the contract. - for OTC derivative transactions negotiated in non-monetary amounts:"]
	extract
        if Trade -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> optionPayout -> underlier -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout exists
            then Trade -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> optionPayout -> underlier -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> priceQuantity -> quantitySchedule -> amount

        else if Trade -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout exists
            then Trade -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> priceQuantity -> quantitySchedule -> amount

		//TH -> eq2perf update proposal
		else if Trade -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> performancePayout -> priceQuantity -> quantitySchedule count = 1
            then  Trade -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> performancePayout -> priceQuantity -> quantitySchedule -> amount

		else if Trade -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> optionPayout -> priceQuantity -> quantitySchedule exists
		and  Trade -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> optionPayout -> underlier -> security -> securityType any = SecurityTypeEnum -> Debt
			then Trade -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> optionPayout -> priceQuantity -> quantitySchedule -> amount
	
		else if Trade -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> optionPayout -> priceQuantity -> quantitySchedule exists
		and  Trade -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> optionPayout -> underlier -> security -> securityType any = SecurityTypeEnum -> Equity
			then Trade -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> optionPayout -> priceQuantity -> quantitySchedule -> amount

		else if Qualify_Commodity_Swap_FixedFloat(Trade -> tradableProduct -> product -> contractualProduct -> economicTerms)
            then CommodityLeg1 (Trade -> tradableProduct -> product) -> priceQuantity -> resolvedQuantity -> amount * FixedPriceLeg2(Trade -> tradableProduct -> product) -> fixedPrice -> price -> amount
	
		else if Qualify_Commodity_Option( Trade -> tradableProduct -> product -> contractualProduct -> economicTerms) then Trade -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> optionPayout -> exerciseTerms -> strike -> strikePrice -> amount * Trade -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> optionPayout -> priceQuantity -> resolvedQuantity -> amount

	//TH Comment: This following logic for Commodity Basis is not correct, but at this moment we do not have acces to the last available spot price of the underlying asset
	//else if Qualify_Commodity_Swap_Basis(Trade -> tradableProduct -> product -> contractualProduct -> economicTerms)
    	//  filter when Trade -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> commodityPayout -> commodityPriceReturnTerms -> spread exists
	//  then extract Trade -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> commodityPayout -> priceQuantity -> resolvedQuantity -> amount * Trade -> tradableProduct -> tradeLot -> priceQuantity -> price -> amount

reporting rule CDECommodityNotional <"Commodity Notional">
	//ToDo: Add regulatory reference
	extract if CommodityPayout -> priceQuantity -> quantitySchedule exists
		then CommodityPayout -> priceQuantity -> quantitySchedule -> amount

reporting rule CDEInterestRateNotional <"Interest Rate Notional">
   	[regulatoryReference CPMI_IOSCO CDE section "2" field "70"
		rationale "CDEInterestRateNotional is required due to jurisdictional specific leg level ordering.  When ordering rules are harmonised they could be combined with CDE rules"
		rationale_author "DRR - Nigel Cobb - 28/7/21"
   		provision "For each leg of the transaction, where applicable: - for OTC derivative transactions negotiated in monetary amounts, amount specified in the contract. - for OTC derivative transactions negotiated in non-monetary amounts:"]
   		// Non-Monetary amounts - and potential subdivision - to be tackled in future
		extract
			if InterestRatePayout -> priceQuantity -> quantitySchedule exists
				then InterestRatePayout -> priceQuantity -> quantitySchedule -> amount

reporting rule CDEFXNotional <"Interest Rate Notional">
   	[regulatoryReference CPMI_IOSCO CDE section "2" field "70"
		rationale "CDEFXNotional is required due to jurisdictional specific leg level ordering.  When ordering rules are harmonised they could be combined with CDE rules"
		rationale_author "DRR - Nigel Cobb - 28/7/21"
   		provision "For each leg of the transaction, where applicable: - for OTC derivative transactions negotiated in monetary amounts, amount specified in the contract. - for OTC derivative transactions negotiated in non-monetary amounts:"]
		extract NonNegativeQuantitySchedule -> amount

reporting rule CDENotionalCurrency
	[regulatoryReference CPMI_IOSCO CDE section "2" field "74"
		rationale "See separate CDEInterestRateNotionalCurrency and CDEFXNotionalCurrency which is required due to jurisdictional specific leg level ordering.  When ordering rules are harmonised they could be combined with CDE rules"
		rationale_author "DRR - Nigel Cobb - 28/7/21"
		provision "For each leg of the transaction, where applicable: currency in which the notional amount is denominated."]
		extract if Trade -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> optionPayout -> underlier -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout exists
			then Trade -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> optionPayout -> underlier -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> priceQuantity -> quantitySchedule -> unitOfAmount -> currency
			
		else if Trade -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout exists
            then Trade -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> priceQuantity -> quantitySchedule -> unitOfAmount -> currency

		else if Trade -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> performancePayout count = 1
            		then Trade -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> performancePayout -> priceQuantity -> quantitySchedule -> unitOfAmount -> currency

		//TH Review -> are Vol/Var swaps single leg products?
		else if Trade -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> performancePayout count = 1
            then Trade -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> performancePayout -> priceQuantity -> quantitySchedule -> unitOfAmount -> currency

		else if Trade -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> optionPayout -> priceQuantity -> quantitySchedule exists
			and  Trade -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> optionPayout -> underlier -> security -> securityType any = SecurityTypeEnum -> Debt
			then Trade -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> optionPayout -> priceQuantity -> quantitySchedule -> unitOfAmount -> currency
		
		else if Trade -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> optionPayout -> priceQuantity -> quantitySchedule exists
			and  Trade -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> optionPayout -> underlier -> security -> securityType any = SecurityTypeEnum -> Equity
			then Trade -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> optionPayout -> priceQuantity -> quantitySchedule -> unitOfAmount -> currency

		else if Qualify_Commodity_Swap_FixedFloat( Trade -> tradableProduct -> product -> contractualProduct -> economicTerms) then
            FixedPriceLeg2(Trade -> tradableProduct -> product) -> fixedPrice -> price -> unitOfAmount -> currency

		else if Qualify_Commodity_Option( Trade -> tradableProduct -> product -> contractualProduct -> economicTerms) then ProductForTrade(Trade) -> contractualProduct -> economicTerms -> payout -> optionPayout -> exerciseTerms -> strike -> strikePrice -> unitOfAmount -> currency

reporting rule CDEInterestRateNotionalCurrency
	[regulatoryReference CPMI_IOSCO CDE section "2" field "74"
		rationale "CDEInterestRateNotionalCurrency is required due to jurisdictional specific leg level ordering.  When ordering rules are harmonised they could be combined with CDE rules"
		rationale_author "DRR - Nigel Cobb - 28/7/21"
		provision "For each leg of the transaction, where applicable: currency in which the notional amount is denominated."]
    extract 
		if InterestRatePayout -> priceQuantity -> quantitySchedule exists
			then InterestRatePayout -> priceQuantity -> quantitySchedule -> unitOfAmount -> currency
		else if InterestRatePayout -> priceQuantity -> quantityReference exists
			then InterestRatePayout -> priceQuantity -> quantityReference -> quantitySchedule -> unitOfAmount -> currency

reporting rule CDEFXNotionalCurrency
	[regulatoryReference CPMI_IOSCO CDE section "2" field "74"
		rationale "CDEFXNotionalCurrency is required due to jurisdictional specific leg level ordering.  When ordering rules are harmonised they could be combined with CDE rules"
		rationale_author "DRR - Nigel Cobb - 28/7/21"
		provision "For each leg of the transaction, where applicable: currency in which the notional amount is denominated."]
    extract Quantity -> unitOfAmount -> currency
*/

reporting rule CDECommodityCurrency
	extract if CommodityPayout -> priceQuantity -> quantitySchedule exists
		then CommodityPayout -> priceQuantity -> quantitySchedule -> unitOfAmount -> currency

reporting rule CDECallCurrency <"Call Currency">
    [regulatoryReference CPMI_IOSCO CDE section "2" field "75"
        rationale_author "REGnosys-Saeid"
        rationale "The call currency is determined by a validation rule which determines who is the buyer of the option."
        provision "For foreign exchange options, the currency in which the Call amount is denominated."]
    (
        extract TradeForEvent( ReportableEvent ) then 
            filter when Qualify_Commodity_Option( Trade -> tradableProduct -> product -> contractualProduct -> economicTerms) then 
                extract ProductForTrade( Trade ) then 
                    filter when IsCallOption( Product ) then 
                        extract Product -> contractualProduct -> economicTerms -> payout -> optionPayout -> exerciseTerms -> strike -> strikePrice -> unitOfAmount -> currency
        ,
		//Equity option with monetary quantity schedule
        extract TradeForEvent( ReportableEvent ) then 
            filter when IsEquityOption( Trade -> tradableProduct -> product ) then 
            extract ProductForTrade( Trade ) then filter when IsCallOption( Product ) and Product -> contractualProduct -> economicTerms -> payout -> optionPayout -> priceQuantity -> quantitySchedule -> unitOfAmount -> currency exists then
            extract Product -> contractualProduct -> economicTerms -> payout -> optionPayout -> priceQuantity -> quantitySchedule -> unitOfAmount -> currency
		,
		//Equity option with non-monetary quantity schedule
        extract TradeForEvent( ReportableEvent ) then 
            filter when IsEquityOption( Trade -> tradableProduct -> product ) then 
            extract ProductForTrade( Trade ) then filter when IsCallOption( Product ) and Product -> contractualProduct -> economicTerms -> payout -> optionPayout -> priceQuantity -> quantitySchedule -> unitOfAmount -> financialUnit exists then
            extract Product -> contractualProduct -> economicTerms -> payout -> optionPayout -> exerciseTerms -> strike -> strikePrice -> unitOfAmount -> currency
    ,
        CDECallQuantity then 
            extract NonNegativeQuantitySchedule -> unitOfAmount -> currency
    )

reporting rule CDEPutCurrency <"Put Currency">
    [regulatoryReference CPMI_IOSCO CDE section "2" field "76"
        rationale_author "REGnosys-Saeid"
        rationale "The put currency is determined by a validation rule which determines who is the buyer of the option."
        provision "For foreign exchange options, the currency in which the Put amount is denominated."]
    (
        extract TradeForEvent( ReportableEvent ) then 
            filter when Qualify_Commodity_Option( Trade -> tradableProduct -> product -> contractualProduct -> economicTerms) then 
                extract ProductForTrade( Trade ) then 
                    filter when IsPutOption( Product ) then 
                        extract Product -> contractualProduct -> economicTerms -> payout -> optionPayout -> exerciseTerms -> strike -> strikePrice -> unitOfAmount -> currency
        ,
		//Equity option with monetary quantity schedule
        extract TradeForEvent( ReportableEvent ) then 
            filter when IsEquityOption( Trade -> tradableProduct -> product ) then 
            extract ProductForTrade( Trade ) then filter when IsPutOption( Product ) and Product -> contractualProduct -> economicTerms -> payout -> optionPayout -> priceQuantity -> quantitySchedule -> unitOfAmount -> currency exists then
            extract Product -> contractualProduct -> economicTerms -> payout -> optionPayout -> priceQuantity -> quantitySchedule -> unitOfAmount -> currency
		,
		//Equity option with non-monetary quantity schedule
        extract TradeForEvent( ReportableEvent ) then 
            filter when IsEquityOption( Trade -> tradableProduct -> product ) then 
            extract ProductForTrade( Trade ) then filter when IsPutOption( Product ) and Product -> contractualProduct -> economicTerms -> payout -> optionPayout -> priceQuantity -> quantitySchedule -> unitOfAmount -> financialUnit exists then
            extract Product -> contractualProduct -> economicTerms -> payout -> optionPayout -> exerciseTerms -> strike -> strikePrice -> unitOfAmount -> currency
    ,
        CDEPutQuantity then 
            extract NonNegativeQuantitySchedule -> unitOfAmount -> currency
    )

reporting rule CDEQuantityUnitOfMeasure
    [regulatoryReference CPMI_IOSCO CDE section "2" field "77"
        provision "For each leg of the transaction, where applicable: unit of measure in which the Total notional
            quantity and the Notional quantity schedules are expressed."]
	extract NonNegativeQuantitySchedule -> unitOfAmount then
        extract if UnitType -> capacityUnit exists then CapacityUnitToISO20022UnitOfMeasure(UnitType -> capacityUnit)
            else if UnitType -> weatherUnit exists then WeatherUnitToISO20022UnitOfMeasure(UnitType -> weatherUnit)
			else if UnitType -> financialUnit exists then FinancialUnitToISO20022UnitOfMeasure(UnitType -> financialUnit)

reporting rule CDENotionalAmountScheduleEffectiveDate <"Effective date of the notional amount">
	[regulatoryReference CPMI_IOSCO CDE section "2" field "78.1"
		provision "Unadjusted date on which the associated notional amount of becomes effective."]
		extract Step -> stepDate
		as "Effective date of the notional amount"

reporting rule CDENotionalAmountScheduleEndDate <"End date of the notional amount">
	[regulatoryReference CPMI_IOSCO CDE section "2" field "78.2"
		provision "Unadjusted end date of the notional amount (not applicable if the unadjusted end date of a given schedules period is back-to-back with the unadjusted effective date of the subsequent period)."]
		return "-"
		// CDM and FpML do not have any concept of end date
		as "End date of the notional amount"

reporting rule CDENotionalAmountScheduleAmount <"Notional amount in effect on associated effective date">
	[regulatoryReference CPMI_IOSCO CDE section "2" field "78.3"
		provision "Notional amount which becomes effective on the associated unadjusted effective date."]
	extract Step -> stepValue as "Notional amount in effect on associated effective date"

reporting rule CDECallQuantity <"Call Quantity - Utility function">
	extract TradeForEvent( ReportableEvent ) then
	(
		/*filter when IsFXOption( Trade ) then
			extract if Trade -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> optionPayout -> buyerSeller -> buyer = Trade -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> optionPayout -> underlier -> foreignExchange -> exchangedCurrency1 -> payerReceiver -> receiver then
			Trade -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> optionPayout -> underlier -> foreignExchange -> exchangedCurrency1 -> priceQuantity -> resolvedQuantity
			else Trade -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> optionPayout -> underlier -> foreignExchange -> exchangedCurrency2 -> priceQuantity -> resolvedQuantity
		,*/
		extract ProductForTrade( Trade )  then
		(
			/*filter when IsCallOption( Product ) then
				extract Product -> contractualProduct -> economicTerms -> payout -> optionPayout -> priceQuantity,*/
			filter when (IsCallOption (Product) and Qualify_CreditDefaultSwaption (Product -> contractualProduct -> economicTerms) = True) then 
				extract UnderlierForProduct(Product) then 
					extract Product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout-> priceQuantity,
			filter when Qualify_InterestRate_Option_Swaption (Product -> contractualProduct -> economicTerms) = True then
				extract Product -> contractualProduct -> economicTerms -> payout -> optionPayout -> underlier -> contractualProduct -> economicTerms -> payout -> interestRatePayout
					filter [ item -> rateSpecification -> fixedRate exists ]
					filter [ item -> payerReceiver -> receiver = Product -> contractualProduct -> economicTerms -> payout -> optionPayout only-element -> buyerSeller -> buyer ]
					map [ item -> priceQuantity ],
			filter when IsCap( Product ) then
				extract Product -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> priceQuantity
		) then extract 
			if ResolvablePriceQuantity -> quantitySchedule exists
				then ResolvablePriceQuantity -> quantitySchedule
			else if ResolvablePriceQuantity -> quantityReference exists
				then ResolvablePriceQuantity -> quantityReference -> quantitySchedule
			//else ResolvablePriceQuantity -> resolvedQuantity
	)

reporting rule CDEPutQuantity <"Put Quantity - Utility function">
	extract TradeForEvent( ReportableEvent ) then
	(
		/*filter when IsFXOption( Trade ) then
			extract if Trade -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> optionPayout -> buyerSeller -> buyer = Trade -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> optionPayout -> underlier -> foreignExchange -> exchangedCurrency1 -> payerReceiver -> receiver then
            Trade -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> optionPayout -> underlier -> foreignExchange -> exchangedCurrency2 -> priceQuantity -> resolvedQuantity
			else Trade -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> optionPayout -> underlier -> foreignExchange -> exchangedCurrency1 -> priceQuantity -> resolvedQuantity
		,*/
		extract ProductForTrade( Trade )  then
		(
			/*filter when IsPutOption( Product ) then
				extract Product -> contractualProduct -> economicTerms -> payout -> optionPayout -> priceQuantity,*/
			filter when (IsPutOption (Product) and Qualify_CreditDefaultSwaption (Product -> contractualProduct -> economicTerms) = True) then 
				extract UnderlierForProduct(Product) then 
					extract Product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout-> priceQuantity,
			filter when Qualify_InterestRate_Option_Swaption (Product -> contractualProduct -> economicTerms) = True then
				extract Product -> contractualProduct -> economicTerms -> payout -> optionPayout -> underlier -> contractualProduct -> economicTerms -> payout -> interestRatePayout
					filter [ item -> rateSpecification -> fixedRate exists ]
					filter [ item -> payerReceiver -> payer = Product -> contractualProduct -> economicTerms -> payout -> optionPayout only-element -> buyerSeller -> buyer ]
					map [ item -> priceQuantity ],
			filter when IsFloor( Product ) then
				extract Product -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> priceQuantity
		) then extract 
			if ResolvablePriceQuantity -> quantitySchedule exists
				then ResolvablePriceQuantity -> quantitySchedule
			else if ResolvablePriceQuantity -> quantityReference exists
				then ResolvablePriceQuantity -> quantityReference -> quantitySchedule
			//else ResolvablePriceQuantity -> resolvedQuantity
	)

reporting rule CDECDSIndexAttachmentPoint <"CDS Index Attachment Point">
  	[regulatoryReference CPMI_IOSCO CDE section "2" field "81"
  		provision "Defined lower point at which the level of losses in the underlying portfolio reduces the notional of a tranche. For example, the notional in a tranche with an attachment point of 3% will be reduced after 3% of losses in the portfolio have occurred. This data element is not applicable if the transaction is not a CDS tranche transaction (index or custom basket)."]
	extract TradeForEvent( ReportableEvent )
		then extract Trade -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> generalTerms
		then extract
			if GeneralTerms -> indexReferenceInformation -> tranche exists
				then GeneralTerms -> indexReferenceInformation -> tranche -> attachmentPoint
			else if GeneralTerms -> basketReferenceInformation -> tranche exists
				then GeneralTerms -> basketReferenceInformation -> tranche -> attachmentPoint
		   as "2.81 CDS Index Attachment Point"

reporting rule CDECDSIndexDetachmentPoint <"CDS Index Detachment Point">
  	[regulatoryReference CPMI_IOSCO CDE section "2" field "82"
  		provision "Defined point beyond which losses in the underlying portfolio no longer reduce the notional of a tranche. For example, the notional in a tranche with an attachment point of 3% and a detachment point of 6% will be reduced after there have been 3% of losses in the portfolio. 6% losses in the portfolio deplete the notional of the tranche. This data element is not applicable if the transaction is not a CDS tranche transaction (index or custom basket)."]
	extract TradeForEvent( ReportableEvent )
		then extract Trade -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> generalTerms
		then extract
			if GeneralTerms -> indexReferenceInformation -> tranche exists
				then GeneralTerms -> indexReferenceInformation -> tranche -> exhaustionPoint
			else if GeneralTerms -> basketReferenceInformation -> tranche exists
				then GeneralTerms -> basketReferenceInformation -> tranche -> exhaustionPoint
		   as "2.82 CDS Index Detachment Point"

//Other Payment fields proposal CDE 2.83-2.88

reporting rule CDEOtherPayment3 <"Other Payment 3">
    [regulatoryReference CPMI_IOSCO CDE section "2" field "83-88"
        provision "Type of Other payment amount. Option  premium  payment  is  not  included  as  a  payment  type  as  premiums  for  option  are reported using the option premium dedicated data element."]
    extract TradeForEvent( ReportableEvent ) then
        extract Trade -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> principalPayment -> principalPaymentSchedule -> initialPrincipalPayment
        // finalPrincipalPayment?

reporting rule CDEOtherPaymentAmount <"Other Payment Amount ">
    [regulatoryReference CPMI_IOSCO CDE section "2" field "83"
        provision "Payment  amounts  with  corresponding  payment  types  to  accommodate  requirements  of transaction descriptions from different asset classes."]
	extract TransferState -> transfer -> quantity -> amount as "2.83 Other Payment Amount"

reporting rule CDEOtherPaymentAmount3 <"Other Payment Amount 3">
     [regulatoryReference CPMI_IOSCO CDE section "2" field "83"
        provision "Payment  amounts  with  corresponding  payment  types  to  accommodate  requirements  of transaction descriptions from different asset classes."]
 	extract PrincipalPayment -> principalAmount -> amount
 	as "Other Payment Amount"

reporting rule CDEOtherPaymentType <"Other Payment Type">
    [regulatoryReference CPMI_IOSCO CDE section "2" field "84"
        provision "Type of Other payment amount. Option  premium  payment  is  not  included  as  a  payment  type  as  premiums  for  option  are reported using the option premium dedicated data element. 
			1 = Upfront Payment, ie the initial payment made by one of the counterparties either to bring a transaction to fair value or for any other reason that may be the cause of an off-market transaction.
			2 = Unwind or Full termination, ie the final settlement payment made when a transaction is unwound prior to its end date; Payments that may result due to full termination of derivative transaction(s)
			3 = Principal Exchange, ie Exchange of notional values for cross-currency swaps"]
    extract TransferState -> transfer -> transferExpression then
        extract if TransferExpression -> priceTransfer = FeeTypeEnum -> Upfront then 1
            else if TransferExpression -> priceTransfer = FeeTypeEnum -> Termination 
                or TransferExpression -> priceTransfer = FeeTypeEnum -> PartialTermination then 2
            else if TransferExpression -> scheduledTransfer -> transferType = TransferTypeEnum -> PrincipalPayment then 3
 	as "2.84 Other Payment Type"

reporting rule CDEOtherPaymentType3 <"Other Payment Type 3">
    [regulatoryReference CPMI_IOSCO CDE section "2" field "84"
        provision "Type of Other payment amount. Option  premium  payment  is  not  included  as  a  payment  type  as  premiums  for  option  are reported using the option premium dedicated data element. 3 = Principal Exchange, ie Exchange of notional values for cross-currency swaps."]
    return "3"
 	as "Other Payment Type"

reporting rule CDEOtherPaymentCurrency <"Other Payment Currency">
    [regulatoryReference CPMI_IOSCO CDE section "2" field "85"
        provision "Currency in which Other payment amount is denominated."]
	extract TransferState -> transfer -> quantity -> unitOfAmount -> currency as "2.85 Other Payment Currency"

// Need to refactor Principle Exchange to include currency
// reporting rule CDEOtherPaymentCurrency3 <"Other Payment Currency">
//     [regulatoryReference CPMI_IOSCO CDE section "2" field "85"
//         provision "Currency in which Other payment amount is denominated."]
//     // CDEOtherPayment3 then
//         extract InterestRatePayout -> priceQuantity -> quantitySchedule -> unitOfAmount -> currency

reporting rule CDEOtherPaymentDate <"Other Payment Date">
	[regulatoryReference CPMI_IOSCO CDE section "2" field "86"
		provision "Unadjusted date on which the other payment amount is paid."]
	extract TransferState -> transfer -> settlementDate -> unadjustedDate as "2.86 Other Payment Date"

reporting rule CDEOtherPaymentDate3 <"Other Payment Date 3">
    [regulatoryReference CPMI_IOSCO CDE section "2" field "86"
		provision "Unadjusted date on which the Other payment amount is paid."]
    extract if PrincipalPayment -> principalPaymentDate -> unadjustedDate exists
		then PrincipalPayment -> principalPaymentDate -> unadjustedDate
		else PrincipalPayment -> principalPaymentDate -> adjustedDate
 	as "Other Payment Date"

reporting rule CDEOtherPaymentPayer <"Other Payment Payer">
	[regulatoryReference CPMI_IOSCO CDE section "2" field "87"
        provision "Identifier of the payer of Other payment amount."]
   	extract TransferState -> transfer -> payerReceiver -> payerPartyReference then
		extract PartyLei(Party->partyId)
			as "2.87 Other Payment Payer"

reporting rule CDEOtherPaymentReceiver <"Other Payment Receiver 1">
	[regulatoryReference CPMI_IOSCO CDE section "2" field "88"
        provision "Identifier of the payer of Other payment amount."]
	extract TransferState -> transfer -> payerReceiver -> receiverPartyReference then
		extract PartyLei(Party->partyId)
			as "2.88 Other Payment Receiver"
//End of CDE 2.83-2.88

reporting rule CDEPackageIdentifier <"Package Identifier">
	[regulatoryReference CPMI_IOSCO CDE section "2" field "89"
		provision "Identifier (determined by the reporting counterparty) in order to connect two or more transactions that are reported separately by the reporting counterparty, but that are negotiated together as the product of a single economic agreement, two or more reports pertaining to the same transaction whenever jurisdictional reporting requirement does not allow the transaction to be reported with a single report to TRs. A package may include reportable and non-reportable transactions. This data element is not applicable if no package is involved, or to allocations. Where the package identifier is not known when a new transaction is reported, the package identifier is updated as it becomes available."]
	extract
		if ReportableEvent -> originatingWorkflowStep -> businessEvent -> packageInformation exists then
			ReportableEvent -> originatingWorkflowStep -> businessEvent -> packageInformation -> listId -> assignedIdentifier -> identifier
		else if ReportableEvent -> originatingWorkflowStep -> businessEvent -> after -> trade -> executionDetails -> packageReference exists then
			ReportableEvent -> originatingWorkflowStep -> businessEvent -> after -> trade -> executionDetails -> packageReference -> listId -> assignedIdentifier -> identifier

reporting rule CDEPackagePrice <"Packages Price">
	[regulatoryReference CPMI_IOSCO CDE section "2" field "90"
		provision "Traded price of the entire package in which the reported derivative transaction is a component. This data element is not applicable if no package is involved, or package transaction spread is used. Prices and related data elements of the transactions (P Price currency, Price notation, Price unit of measure) that represent individual components of the package are reported when available. The package transaction price may not be known when a new transaction is reported but may be updated later."]
	extract Package_Contract_Price_Monetary( Trade )
        then extract PriceSchedule -> amount
	/*extract ReportableEvent -> originatingWorkflowStep -> businessEvent -> packageInformation -> price
		then extract PriceSchedule -> amount*/

reporting rule CDEPackagePriceCurrency <"Packages Price Currency">
	[regulatoryReference CPMI_IOSCO CDE section "2" field "91"
		provision "Currency in which the Package transaction price is denominated. This data element is not applicable if no package is involved, or Package transaction spread is used, or Package transaction price notation = 2 , or = 3"]
	extract Package_Contract_Price_Monetary( Trade ) then
		extract if IsPriceMonetary( PriceSchedule )
			then PriceSchedule -> unitOfAmount -> currency
/*	extract ReportableEvent -> originatingWorkflowStep -> businessEvent -> packageInformation -> price
		then extract PriceSchedule -> unitOfAmount -> currency*/

reporting rule CDEPackagePriceNotation <"Packages Price Notation">
	[regulatoryReference CPMI_IOSCO CDE section "2" field "92"
		provision "Manner in which the Package transaction price is expressed. This data element is not applicable if no package is involved, or Package transaction spread is used"]
	extract Package_Contract_Price_Monetary( Trade ) then
		extract if IsPriceMonetary( PriceSchedule )
		then "1"
		else "3"
	/*extract ReportableEvent -> originatingWorkflowStep -> businessEvent -> packageInformation -> price then
		extract if IsPriceMonetary( PriceSchedule ) then "1"
		else "3"*/

reporting rule CDEPackageSpread <"Packages Spread">
	[regulatoryReference CPMI_IOSCO CDE section "2" field "93"
		provision "Traded price of the entire package in which the reported derivative transaction is a component of a package transaction. Package transaction price when the price of the package is expressed as a spread, difference between two reference prices. This data element is not applicable if no package is involved, or Package transaction price is used. Spread and related data elements of the transactions (spread currency, Spread notation) that represent individual components of the package are reported when available. Package transaction spread may not be known when a new transaction is reported but may be updated later."]
	extract SpreadSchedule -> price -> amount

reporting rule CDEPackageSpreadCurrency <"Packages Spread Currency">
	[regulatoryReference CPMI_IOSCO CDE section "2" field "94"
		provision "Currency in which the Package transaction spread is denominated. This data element is not applicable if no package is involved, or Package transaction price is used, or Package transaction spread notation = 2, or = 3 or = 4"]
	extract SpreadSchedule -> price then
                filter when IsPriceMonetary( PriceSchedule )  then
                    extract PriceSchedule -> unitOfAmount -> currency

reporting rule CDEPackageSpreadNotation <"Packages Spread Notation">
	[regulatoryReference CPMI_IOSCO CDE section "2" field "95"
		provision "Manner in which the Package transaction spread is expressed. This data element is not applicable if no package is involved, or Package transaction price is used"]
	extract if IsPriceMonetary( SpreadSchedule -> price )
                    then 1
                    else 3

reporting rule CDEPriorUTI
	[regulatoryReference CPMI_IOSCO CDE section "2" field "96"
		provision "UTI assigned to the predecessor transaction that has given rise to the reported transaction due to a lifecycle event, in a one-to-one relation between transactions (eg in the case of a novation, when transaction is terminated, and a new transaction is generated) or in a one-to-many relation between transactions (eg in clearing or if a transaction is split into several different transactions). This data element is not applicable when reporting many-to-one and many-to-many relations between transactions (eg in the case of a compression)."]
	extract Trade -> tradeIdentifier -> assignedIdentifier then
            filter when AssignedIdentifier -> identifierType = TradeIdentifierTypeEnum -> UniqueTransactionIdentifier then
                extract AssignedIdentifier -> identifier

//UPI reporting rule
reporting rule UPIOptionType <"Option Type">
	[regulatoryReference CPMI_IOSCO UPI section "4.2.1" field "Option Type"
		provision "Specifies whether an option gives the buyer the right to buy the underlying, ie Call, the right to sell the underlying, ie Put, or the right to choose whether to buy or sell the underlying at the time of exercise, ie Chooser."]
	(
	filter when IsPutOption( Product )
		then extract "PUTO",
	filter when IsFloor( Product )
		then extract "PUTO",
	filter when IsCallOption( Product )
		then extract "CALL",
	filter when IsCap( Product )
		then extract "CALL"
	)
	as "4.2.1 Option Type"
